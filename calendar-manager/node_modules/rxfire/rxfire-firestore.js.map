{"version":3,"file":"rxfire-firestore.js","sources":["firestore/fromRef.ts","firestore/document/index.ts","firestore/collection/index.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { firestore } from 'firebase/app';\nimport { Observable } from 'rxjs';\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\nfunction _fromRef(\n  ref: any,\n  options: firestore.SnapshotListenOptions | undefined\n): Observable<any> {\n  /* eslint-enable @typescript-eslint/no-explicit-any */\n  return new Observable(subscriber => {\n    const unsubscribe = ref.onSnapshot(options || {}, subscriber);\n    return { unsubscribe };\n  });\n}\n\nexport function fromRef(\n  ref: firestore.DocumentReference | firestore.Query,\n  options?: firestore.SnapshotListenOptions\n): Observable<{}> {\n  return _fromRef(ref, options);\n}\n\nexport function fromDocRef(\n  ref: firestore.DocumentReference,\n  options?: firestore.SnapshotListenOptions\n): Observable<firestore.DocumentSnapshot> {\n  return fromRef(ref, options) as Observable<firestore.DocumentSnapshot>;\n}\n\nexport function fromCollectionRef(\n  ref: firestore.Query,\n  options?: firestore.SnapshotListenOptions\n): Observable<firestore.QuerySnapshot> {\n  return fromRef(ref, options) as Observable<firestore.QuerySnapshot>;\n}\n","/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { firestore } from 'firebase/app';\nimport { fromDocRef } from '../fromRef';\nimport { map } from 'rxjs/operators';\nimport { Observable } from 'rxjs';\n\nexport function doc(\n  ref: firestore.DocumentReference\n): Observable<firestore.DocumentSnapshot> {\n  return fromDocRef(ref);\n}\n\n/**\n * Returns a stream of a document, mapped to its data payload and optionally the document ID\n * @param query\n */\nexport function docData<T>(\n  ref: firestore.DocumentReference,\n  idField?: string\n): Observable<T> {\n  return doc(ref).pipe(map(snap => snapToData(snap, idField) as T));\n}\n\nexport function snapToData(\n  snapshot: firestore.DocumentSnapshot,\n  idField?: string\n): {} {\n  return {\n    ...snapshot.data(),\n    ...(idField ? { [idField]: snapshot.id } : null)\n  };\n}\n","/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { firestore } from 'firebase/app';\nimport { fromCollectionRef } from '../fromRef';\nimport { Observable, MonoTypeOperatorFunction } from 'rxjs';\nimport { map, filter, scan, distinctUntilChanged } from 'rxjs/operators';\nimport { snapToData } from '../document';\n\nconst ALL_EVENTS: firestore.DocumentChangeType[] = [\n  'added',\n  'modified',\n  'removed'\n];\n\n/**\n * Create an operator that determines if a the stream of document changes\n * are specified by the event filter. If the document change type is not\n * in specified events array, it will not be emitted.\n */\nconst filterEvents = (\n  events?: firestore.DocumentChangeType[]\n): MonoTypeOperatorFunction<firestore.DocumentChange[]> =>\n  filter((changes: firestore.DocumentChange[]) => {\n    let hasChange = false;\n    for (let i = 0; i < changes.length; i++) {\n      const change = changes[i];\n      if (events && events.indexOf(change.type) >= 0) {\n        hasChange = true;\n        break;\n      }\n    }\n    return hasChange;\n  });\n\n/**\n * Create an operator that filters out empty changes. We provide the\n * ability to filter on events, which means all changes can be filtered out.\n * This creates an empty array and would be incorrect to emit.\n */\nconst filterEmpty = filter(\n  (changes: firestore.DocumentChange[]) => changes.length > 0\n);\n\n/**\n * Splice arguments on top of a sliced array, to break top-level ===\n * this is useful for change-detection\n */\nfunction sliceAndSplice<T>(\n  original: T[],\n  start: number,\n  deleteCount: number,\n  ...args: T[]\n): T[] {\n  const returnArray = original.slice();\n  returnArray.splice(start, deleteCount, ...args);\n  return returnArray;\n}\n\n/**\n * Creates a new sorted array from a new change.\n * @param combined\n * @param change\n */\nfunction processIndividualChange(\n  combined: firestore.DocumentChange[],\n  change: firestore.DocumentChange\n): firestore.DocumentChange[] {\n  switch (change.type) {\n    case 'added':\n      if (\n        combined[change.newIndex] &&\n        combined[change.newIndex].doc.ref.isEqual(change.doc.ref)\n      ) {\n        // Skip duplicate emissions. This is rare.\n        // TODO: Investigate possible bug in SDK.\n      } else {\n        return sliceAndSplice(combined, change.newIndex, 0, change);\n      }\n      break;\n    case 'modified':\n      if (\n        combined[change.oldIndex] == null ||\n        combined[change.oldIndex].doc.ref.isEqual(change.doc.ref)\n      ) {\n        // When an item changes position we first remove it\n        // and then add it's new position\n        if (change.oldIndex !== change.newIndex) {\n          const copiedArray = combined.slice();\n          copiedArray.splice(change.oldIndex, 1);\n          copiedArray.splice(change.newIndex, 0, change);\n          return copiedArray;\n        } else {\n          return sliceAndSplice(combined, change.newIndex, 1, change);\n        }\n      }\n      break;\n    case 'removed':\n      if (\n        combined[change.oldIndex] &&\n        combined[change.oldIndex].doc.ref.isEqual(change.doc.ref)\n      ) {\n        return sliceAndSplice(combined, change.oldIndex, 1);\n      }\n      break;\n    default: // ignore\n  }\n  return combined;\n}\n\n/**\n * Combines the total result set from the current set of changes from an incoming set\n * of changes.\n * @param current\n * @param changes\n * @param events\n */\nfunction processDocumentChanges(\n  current: firestore.DocumentChange[],\n  changes: firestore.DocumentChange[],\n  events: firestore.DocumentChangeType[] = ALL_EVENTS\n): firestore.DocumentChange[] {\n  changes.forEach(change => {\n    // skip unwanted change types\n    if (events.indexOf(change.type) > -1) {\n      current = processIndividualChange(current, change);\n    }\n  });\n  return current;\n}\n\n/**\n * Return a stream of document changes on a query. These results are not in sort order but in\n * order of occurence.\n * @param query\n */\nexport function collectionChanges(\n  query: firestore.Query,\n  events: firestore.DocumentChangeType[] = ALL_EVENTS\n): Observable<firestore.DocumentChange[]> {\n  return fromCollectionRef(query).pipe(\n    map(snapshot => snapshot.docChanges()),\n    filterEvents(events),\n    filterEmpty\n  );\n}\n\n/**\n * Return a stream of document snapshots on a query. These results are in sort order.\n * @param query\n */\nexport function collection(\n  query: firestore.Query\n): Observable<firestore.QueryDocumentSnapshot[]> {\n  return fromCollectionRef(query).pipe(map(changes => changes.docs));\n}\n\n/**\n * Return a stream of document changes on a query. These results are in sort order.\n * @param query\n */\nexport function sortedChanges(\n  query: firestore.Query,\n  events?: firestore.DocumentChangeType[]\n): Observable<firestore.DocumentChange[]> {\n  return collectionChanges(query, events).pipe(\n    scan(\n      (\n        current: firestore.DocumentChange[],\n        changes: firestore.DocumentChange[]\n      ) => processDocumentChanges(current, changes, events),\n      []\n    ),\n    distinctUntilChanged()\n  );\n}\n\n/**\n * Create a stream of changes as they occur it time. This method is similar\n * to docChanges() but it collects each event in an array over time.\n */\nexport function auditTrail(\n  query: firestore.Query,\n  events?: firestore.DocumentChangeType[]\n): Observable<firestore.DocumentChange[]> {\n  return collectionChanges(query, events).pipe(\n    scan(\n      (current, action) => [...current, ...action],\n      [] as firestore.DocumentChange[]\n    )\n  );\n}\n\n/**\n * Returns a stream of documents mapped to their data payload, and optionally the document ID\n * @param query\n */\nexport function collectionData<T>(\n  query: firestore.Query,\n  idField?: string\n): Observable<T[]> {\n  return collection(query).pipe(\n    map(arr => {\n      return arr.map(snap => snapToData(snap, idField) as T);\n    })\n  );\n}\n"],"names":["fromRef","ref","options","Observable","subscriber","unsubscribe","onSnapshot","fromDocRef","fromCollectionRef","doc","snapToData","snapshot","idField","data","id","ALL_EVENTS","filterEvents","events","filter","changes","hasChange","i","length","change","indexOf","type","filterEmpty","sliceAndSplice","original","start","deleteCount","_i","args","returnArray","slice","splice","processDocumentChanges","current","forEach","combined","newIndex","isEqual","oldIndex","copiedArray","processIndividualChange","collectionChanges","query","pipe","map","docChanges","collection","docs","scan","action","arr","snap","distinctUntilChanged"],"mappings":"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"}