{"ast":null,"code":"import { __assign, __spreadArrays } from 'tslib';\nimport { Observable } from 'rxjs';\nimport { map, filter, scan, distinctUntilChanged } from 'rxjs/operators';\n/**\r\n * @license\r\n * Copyright 2018 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\nfunction _fromRef(ref, options) {\n  /* eslint-enable @typescript-eslint/no-explicit-any */\n  return new Observable(function (subscriber) {\n    var unsubscribe = ref.onSnapshot(options || {}, subscriber);\n    return {\n      unsubscribe: unsubscribe\n    };\n  });\n}\n\nfunction fromRef(ref, options) {\n  return _fromRef(ref, options);\n}\n\nfunction fromDocRef(ref, options) {\n  return fromRef(ref, options);\n}\n\nfunction fromCollectionRef(ref, options) {\n  return fromRef(ref, options);\n}\n/**\r\n * @license\r\n * Copyright 2018 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n\nfunction doc(ref) {\n  return fromDocRef(ref);\n}\n/**\r\n * Returns a stream of a document, mapped to its data payload and optionally the document ID\r\n * @param query\r\n */\n\n\nfunction docData(ref, idField) {\n  return doc(ref).pipe(map(function (snap) {\n    return snapToData(snap, idField);\n  }));\n}\n\nfunction snapToData(snapshot, idField) {\n  var _a;\n\n  return __assign(__assign({}, snapshot.data()), idField ? (_a = {}, _a[idField] = snapshot.id, _a) : null);\n}\n/**\r\n * @license\r\n * Copyright 2018 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n\nvar ALL_EVENTS = ['added', 'modified', 'removed'];\n/**\r\n * Create an operator that determines if a the stream of document changes\r\n * are specified by the event filter. If the document change type is not\r\n * in specified events array, it will not be emitted.\r\n */\n\nvar filterEvents = function (events) {\n  return filter(function (changes) {\n    var hasChange = false;\n\n    for (var i = 0; i < changes.length; i++) {\n      var change = changes[i];\n\n      if (events && events.indexOf(change.type) >= 0) {\n        hasChange = true;\n        break;\n      }\n    }\n\n    return hasChange;\n  });\n};\n/**\r\n * Create an operator that filters out empty changes. We provide the\r\n * ability to filter on events, which means all changes can be filtered out.\r\n * This creates an empty array and would be incorrect to emit.\r\n */\n\n\nvar filterEmpty = filter(function (changes) {\n  return changes.length > 0;\n});\n/**\r\n * Splice arguments on top of a sliced array, to break top-level ===\r\n * this is useful for change-detection\r\n */\n\nfunction sliceAndSplice(original, start, deleteCount) {\n  var args = [];\n\n  for (var _i = 3; _i < arguments.length; _i++) {\n    args[_i - 3] = arguments[_i];\n  }\n\n  var returnArray = original.slice();\n  returnArray.splice.apply(returnArray, __spreadArrays([start, deleteCount], args));\n  return returnArray;\n}\n/**\r\n * Creates a new sorted array from a new change.\r\n * @param combined\r\n * @param change\r\n */\n\n\nfunction processIndividualChange(combined, change) {\n  switch (change.type) {\n    case 'added':\n      if (combined[change.newIndex] && combined[change.newIndex].doc.ref.isEqual(change.doc.ref)) ;else {\n        return sliceAndSplice(combined, change.newIndex, 0, change);\n      }\n      break;\n\n    case 'modified':\n      if (combined[change.oldIndex] == null || combined[change.oldIndex].doc.ref.isEqual(change.doc.ref)) {\n        // When an item changes position we first remove it\n        // and then add it's new position\n        if (change.oldIndex !== change.newIndex) {\n          var copiedArray = combined.slice();\n          copiedArray.splice(change.oldIndex, 1);\n          copiedArray.splice(change.newIndex, 0, change);\n          return copiedArray;\n        } else {\n          return sliceAndSplice(combined, change.newIndex, 1, change);\n        }\n      }\n\n      break;\n\n    case 'removed':\n      if (combined[change.oldIndex] && combined[change.oldIndex].doc.ref.isEqual(change.doc.ref)) {\n        return sliceAndSplice(combined, change.oldIndex, 1);\n      }\n\n      break;\n  }\n\n  return combined;\n}\n/**\r\n * Combines the total result set from the current set of changes from an incoming set\r\n * of changes.\r\n * @param current\r\n * @param changes\r\n * @param events\r\n */\n\n\nfunction processDocumentChanges(current, changes, events) {\n  if (events === void 0) {\n    events = ALL_EVENTS;\n  }\n\n  changes.forEach(function (change) {\n    // skip unwanted change types\n    if (events.indexOf(change.type) > -1) {\n      current = processIndividualChange(current, change);\n    }\n  });\n  return current;\n}\n/**\r\n * Return a stream of document changes on a query. These results are not in sort order but in\r\n * order of occurence.\r\n * @param query\r\n */\n\n\nfunction collectionChanges(query, events) {\n  if (events === void 0) {\n    events = ALL_EVENTS;\n  }\n\n  return fromCollectionRef(query).pipe(map(function (snapshot) {\n    return snapshot.docChanges();\n  }), filterEvents(events), filterEmpty);\n}\n/**\r\n * Return a stream of document snapshots on a query. These results are in sort order.\r\n * @param query\r\n */\n\n\nfunction collection(query) {\n  return fromCollectionRef(query).pipe(map(function (changes) {\n    return changes.docs;\n  }));\n}\n/**\r\n * Return a stream of document changes on a query. These results are in sort order.\r\n * @param query\r\n */\n\n\nfunction sortedChanges(query, events) {\n  return collectionChanges(query, events).pipe(scan(function (current, changes) {\n    return processDocumentChanges(current, changes, events);\n  }, []), distinctUntilChanged());\n}\n/**\r\n * Create a stream of changes as they occur it time. This method is similar\r\n * to docChanges() but it collects each event in an array over time.\r\n */\n\n\nfunction auditTrail(query, events) {\n  return collectionChanges(query, events).pipe(scan(function (current, action) {\n    return __spreadArrays(current, action);\n  }, []));\n}\n/**\r\n * Returns a stream of documents mapped to their data payload, and optionally the document ID\r\n * @param query\r\n */\n\n\nfunction collectionData(query, idField) {\n  return collection(query).pipe(map(function (arr) {\n    return arr.map(function (snap) {\n      return snapToData(snap, idField);\n    });\n  }));\n}\n\nexport { auditTrail, collection, collectionChanges, collectionData, doc, docData, fromCollectionRef, fromDocRef, fromRef, snapToData, sortedChanges };","map":{"version":3,"sources":["../fromRef.ts","../document/index.ts","../collection/index.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { firestore } from 'firebase/app';\nimport { Observable } from 'rxjs';\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\nfunction _fromRef(\n  ref: any,\n  options: firestore.SnapshotListenOptions | undefined\n): Observable<any> {\n  /* eslint-enable @typescript-eslint/no-explicit-any */\n  return new Observable(subscriber => {\n    const unsubscribe = ref.onSnapshot(options || {}, subscriber);\n    return { unsubscribe };\n  });\n}\n\nexport function fromRef(\n  ref: firestore.DocumentReference | firestore.Query,\n  options?: firestore.SnapshotListenOptions\n): Observable<{}> {\n  return _fromRef(ref, options);\n}\n\nexport function fromDocRef(\n  ref: firestore.DocumentReference,\n  options?: firestore.SnapshotListenOptions\n): Observable<firestore.DocumentSnapshot> {\n  return fromRef(ref, options) as Observable<firestore.DocumentSnapshot>;\n}\n\nexport function fromCollectionRef(\n  ref: firestore.Query,\n  options?: firestore.SnapshotListenOptions\n): Observable<firestore.QuerySnapshot> {\n  return fromRef(ref, options) as Observable<firestore.QuerySnapshot>;\n}\n","/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { firestore } from 'firebase/app';\nimport { fromDocRef } from '../fromRef';\nimport { map } from 'rxjs/operators';\nimport { Observable } from 'rxjs';\n\nexport function doc(\n  ref: firestore.DocumentReference\n): Observable<firestore.DocumentSnapshot> {\n  return fromDocRef(ref);\n}\n\n/**\n * Returns a stream of a document, mapped to its data payload and optionally the document ID\n * @param query\n */\nexport function docData<T>(\n  ref: firestore.DocumentReference,\n  idField?: string\n): Observable<T> {\n  return doc(ref).pipe(map(snap => snapToData(snap, idField) as T));\n}\n\nexport function snapToData(\n  snapshot: firestore.DocumentSnapshot,\n  idField?: string\n): {} {\n  return {\n    ...snapshot.data(),\n    ...(idField ? { [idField]: snapshot.id } : null)\n  };\n}\n","/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { firestore } from 'firebase/app';\nimport { fromCollectionRef } from '../fromRef';\nimport { Observable, MonoTypeOperatorFunction } from 'rxjs';\nimport { map, filter, scan, distinctUntilChanged } from 'rxjs/operators';\nimport { snapToData } from '../document';\n\nconst ALL_EVENTS: firestore.DocumentChangeType[] = [\n  'added',\n  'modified',\n  'removed'\n];\n\n/**\n * Create an operator that determines if a the stream of document changes\n * are specified by the event filter. If the document change type is not\n * in specified events array, it will not be emitted.\n */\nconst filterEvents = (\n  events?: firestore.DocumentChangeType[]\n): MonoTypeOperatorFunction<firestore.DocumentChange[]> =>\n  filter((changes: firestore.DocumentChange[]) => {\n    let hasChange = false;\n    for (let i = 0; i < changes.length; i++) {\n      const change = changes[i];\n      if (events && events.indexOf(change.type) >= 0) {\n        hasChange = true;\n        break;\n      }\n    }\n    return hasChange;\n  });\n\n/**\n * Create an operator that filters out empty changes. We provide the\n * ability to filter on events, which means all changes can be filtered out.\n * This creates an empty array and would be incorrect to emit.\n */\nconst filterEmpty = filter(\n  (changes: firestore.DocumentChange[]) => changes.length > 0\n);\n\n/**\n * Splice arguments on top of a sliced array, to break top-level ===\n * this is useful for change-detection\n */\nfunction sliceAndSplice<T>(\n  original: T[],\n  start: number,\n  deleteCount: number,\n  ...args: T[]\n): T[] {\n  const returnArray = original.slice();\n  returnArray.splice(start, deleteCount, ...args);\n  return returnArray;\n}\n\n/**\n * Creates a new sorted array from a new change.\n * @param combined\n * @param change\n */\nfunction processIndividualChange(\n  combined: firestore.DocumentChange[],\n  change: firestore.DocumentChange\n): firestore.DocumentChange[] {\n  switch (change.type) {\n    case 'added':\n      if (\n        combined[change.newIndex] &&\n        combined[change.newIndex].doc.ref.isEqual(change.doc.ref)\n      ) {\n        // Skip duplicate emissions. This is rare.\n        // TODO: Investigate possible bug in SDK.\n      } else {\n        return sliceAndSplice(combined, change.newIndex, 0, change);\n      }\n      break;\n    case 'modified':\n      if (\n        combined[change.oldIndex] == null ||\n        combined[change.oldIndex].doc.ref.isEqual(change.doc.ref)\n      ) {\n        // When an item changes position we first remove it\n        // and then add it's new position\n        if (change.oldIndex !== change.newIndex) {\n          const copiedArray = combined.slice();\n          copiedArray.splice(change.oldIndex, 1);\n          copiedArray.splice(change.newIndex, 0, change);\n          return copiedArray;\n        } else {\n          return sliceAndSplice(combined, change.newIndex, 1, change);\n        }\n      }\n      break;\n    case 'removed':\n      if (\n        combined[change.oldIndex] &&\n        combined[change.oldIndex].doc.ref.isEqual(change.doc.ref)\n      ) {\n        return sliceAndSplice(combined, change.oldIndex, 1);\n      }\n      break;\n    default: // ignore\n  }\n  return combined;\n}\n\n/**\n * Combines the total result set from the current set of changes from an incoming set\n * of changes.\n * @param current\n * @param changes\n * @param events\n */\nfunction processDocumentChanges(\n  current: firestore.DocumentChange[],\n  changes: firestore.DocumentChange[],\n  events: firestore.DocumentChangeType[] = ALL_EVENTS\n): firestore.DocumentChange[] {\n  changes.forEach(change => {\n    // skip unwanted change types\n    if (events.indexOf(change.type) > -1) {\n      current = processIndividualChange(current, change);\n    }\n  });\n  return current;\n}\n\n/**\n * Return a stream of document changes on a query. These results are not in sort order but in\n * order of occurence.\n * @param query\n */\nexport function collectionChanges(\n  query: firestore.Query,\n  events: firestore.DocumentChangeType[] = ALL_EVENTS\n): Observable<firestore.DocumentChange[]> {\n  return fromCollectionRef(query).pipe(\n    map(snapshot => snapshot.docChanges()),\n    filterEvents(events),\n    filterEmpty\n  );\n}\n\n/**\n * Return a stream of document snapshots on a query. These results are in sort order.\n * @param query\n */\nexport function collection(\n  query: firestore.Query\n): Observable<firestore.QueryDocumentSnapshot[]> {\n  return fromCollectionRef(query).pipe(map(changes => changes.docs));\n}\n\n/**\n * Return a stream of document changes on a query. These results are in sort order.\n * @param query\n */\nexport function sortedChanges(\n  query: firestore.Query,\n  events?: firestore.DocumentChangeType[]\n): Observable<firestore.DocumentChange[]> {\n  return collectionChanges(query, events).pipe(\n    scan(\n      (\n        current: firestore.DocumentChange[],\n        changes: firestore.DocumentChange[]\n      ) => processDocumentChanges(current, changes, events),\n      []\n    ),\n    distinctUntilChanged()\n  );\n}\n\n/**\n * Create a stream of changes as they occur it time. This method is similar\n * to docChanges() but it collects each event in an array over time.\n */\nexport function auditTrail(\n  query: firestore.Query,\n  events?: firestore.DocumentChangeType[]\n): Observable<firestore.DocumentChange[]> {\n  return collectionChanges(query, events).pipe(\n    scan(\n      (current, action) => [...current, ...action],\n      [] as firestore.DocumentChange[]\n    )\n  );\n}\n\n/**\n * Returns a stream of documents mapped to their data payload, and optionally the document ID\n * @param query\n */\nexport function collectionData<T>(\n  query: firestore.Query,\n  idField?: string\n): Observable<T[]> {\n  return collection(query).pipe(\n    map(arr => {\n      return arr.map(snap => snapToData(snap, idField) as T);\n    })\n  );\n}\n"]},"metadata":{},"sourceType":"module"}